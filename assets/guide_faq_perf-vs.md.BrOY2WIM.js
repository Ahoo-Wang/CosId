import{_ as e,c as r,a2 as d,o as a}from"./chunks/framework.Dg3afQf7.js";const u=JSON.parse('{"title":"性能对比","description":"","frontmatter":{},"headers":[],"relativePath":"guide/faq/perf-vs.md","filePath":"guide/faq/perf-vs.md","lastUpdated":1760420434000}'),i={name:"guide/faq/perf-vs.md"};function l(o,t,n,s,g,h){return a(),r("div",null,t[0]||(t[0]=[d('<h1 id="性能对比" tabindex="-1">性能对比 <a class="header-anchor" href="#性能对比" aria-label="Permalink to &quot;性能对比&quot;">​</a></h1><p>TODO</p><h2 id="分布式id方案的核心指标" tabindex="-1">分布式ID方案的核心指标 <a class="header-anchor" href="#分布式id方案的核心指标" aria-label="Permalink to &quot;分布式ID方案的核心指标&quot;">​</a></h2><ul><li><strong>全局（相同业务）唯一性</strong>：唯一性保证是<strong>ID</strong>的必要条件，假设ID不唯一就会产生主键冲突，这点很容易可以理解。 <ul><li>通常所说的全局唯一性并不是指所有业务服务都要唯一，而是相同业务服务不同部署副本唯一。 比如 Order 服务的多个部署副本在生成<code>t_order</code>这张表的<code>Id</code>时是要求全局唯一的。至于<code>t_order_item</code>生成的<code>ID</code>与<code>t_order</code>是否唯一，并不影响唯一性约束，也不会产生什么副作用。 不同业务模块间也是同理。即唯一性主要解决的是ID冲突问题。</li></ul></li><li><strong>有序性</strong>：有序性保证是面向查询的数据结构算法（除了Hash算法）所必须的，是<strong>二分查找法</strong>(分而治之)的前提。 <ul><li>MySq-InnoDB B+树是使用最为广泛的，假设 Id 是无序的，B+ 树 为了维护 ID 的有序性，就会频繁的在索引的中间位置插入而挪动后面节点的位置，甚至导致频繁的页分裂，这对于性能的影响是极大的。那么如果我们能够保证ID的有序性这种情况就完全不同了，只需要进行追加写操作。所以 ID 的有序性是非常重要的，也是ID设计不可避免的特性。</li></ul></li><li><strong>吞吐量/性能(ops/time)</strong>：即单位时间（每秒）能产生的ID数量。生成ID是非常高频的操作，也是最为基本的。假设ID生成的性能缓慢，那么不管怎么进行系统优化也无法获得更好的性能。 <ul><li>一般我们会首先生成ID，然后再执行写入操作，假设ID生成缓慢，那么整体性能上限就会受到限制，这一点应该不难理解。</li></ul></li><li><strong>稳定性(time/op)</strong>：稳定性指标一般可以采用<strong>每个操作的时间进行百分位采样</strong>来分析，比如 <em><a href="https://github.com/Ahoo-Wang/CosId" target="_blank" rel="noreferrer">CosId</a></em> 百分位采样 <strong>P9999=0.208 us/op</strong>，即 <strong>0% ~ 99.99%</strong> 的单位操作时间小于等于 <strong>0.208 us/op</strong>。 <ul><li><a href="https://zh.wikipedia.org/wiki/%E7%99%BE%E5%88%86%E4%BD%8D%E6%95%B0" target="_blank" rel="noreferrer">百分位数 WIKI</a> ：统计学术语，若将一组数据从小到大排序，并计算相应的累计百分点，则某百分点所对应数据的值，就称为这百分点的百分位数，以Pk表示第k百分位数。百分位数是用来比较个体在群体中的相对地位量数。</li><li>为什么不用平均<em>每个操作的时间</em>：马老师的身价跟你的身价能平均么？平均后的值有意义不？</li><li>可以使用最小<em>每个操作的时间</em>、最大<em>每个操作的时间</em>作为参考吗？因为最小、最大值只说明了零界点的情况，虽说可以作为稳定性的参考，但依然不够全面。而且<em>百分位数</em>已经覆盖了这俩个指标。</li></ul></li><li><strong>自治性（依赖）</strong>：主要是指对外部环境有无依赖，比如<strong>号段模式</strong>会强依赖第三方存储中间件来获取<code>NexMaxId</code>。自治性还会对可用性造成影响。</li><li><strong>可用性</strong>：分布式ID的可用性主要会受到自治性影响，比如<strong>SnowflakeId</strong>会受到时钟回拨影响，导致处于短暂时间的不可用状态。而<strong>号段模式</strong>会受到第三方发号器（<code>NexMaxId</code>）的可用性影响。 <ul><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%94%A8%E6%80%A7" target="_blank" rel="noreferrer">可用性 WIKI</a> ：在一个给定的时间间隔内，对于一个功能个体来讲，总的可用时间所占的比例。</li><li>MTBF：平均故障间隔</li><li>MDT：平均修复/恢复时间</li><li>Availability=MTBF/(MTBF+MDT)</li><li>假设MTBF为1年，MDT为1小时，即<code>Availability=(365*24)/(365*24+1)=0.999885857778792≈99.99%</code>，也就是我们通常所说对可用性4个9。</li></ul></li><li><strong>适应性</strong>：是指在面对外部环境变化的自适应能力，这里我们主要说的是面对流量突发时动态伸缩分布式ID的性能， <ul><li><strong>SegmentChainId</strong>可以基于<strong>饥饿状态</strong>进行<strong>安全距离</strong>的动态伸缩。</li><li><strong>SnowflakeId</strong>常规位分配方案性能恒定409.6W，虽然可以通过调整位分配方案来获得不同的TPS性能，但是位分配方法的变更是破坏性的，一般根据业务场景确定位分配方案后不再变更。</li></ul></li><li><strong>存储空间</strong>：还是用MySq-InnoDB B+树来举例，普通索引（二级索引）会存储主键值，主键越大占用的内存缓存、磁盘空间也会越大。Page页存储的数据越少，磁盘IO访问的次数会增加。总之在满足业务需求的情况下，尽可能小的存储空间占用在绝大多数场景下都是好的设计原则。</li></ul><h2 id="分布式id的核心算法" tabindex="-1">分布式ID的核心算法 <a class="header-anchor" href="#分布式id的核心算法" aria-label="Permalink to &quot;分布式ID的核心算法&quot;">​</a></h2><h2 id="按位分区算法-snowflakeid" tabindex="-1">按位分区算法 (<code>SnowflakeId</code>) <a class="header-anchor" href="#按位分区算法-snowflakeid" aria-label="Permalink to &quot;按位分区算法 (`SnowflakeId`)&quot;">​</a></h2><table tabindex="0"><thead><tr><th></th><th style="text-align:right;">性能（吞吐量）</th><th style="text-align:right;">稳定性（百分位数）</th><th>自治性（依赖）</th><th>机器号分配器</th><th>机器号回收</th><th style="text-align:left;">使用方式</th></tr></thead><tbody><tr><td><a href="https://github.com/Ahoo-Wang/CosId" target="_blank" rel="noreferrer">CosId</a></td><td style="text-align:right;">4,096,000(ops/s)</td><td style="text-align:right;">P9999=0.244(us/op)</td><td>首次启动，依赖<strong>机器号分配器</strong></td><td>手动分配器、K8S、关系型数据库、Redis、ZooKeeper</td><td>支持</td><td style="text-align:left;">SDK(推荐)/RPC/RESTful</td></tr><tr><td><a href="https://github.com/Meituan-Dianping/Leaf" target="_blank" rel="noreferrer">Leaf</a></td><td style="text-align:right;"></td><td style="text-align:right;"></td><td></td><td>ZooKeeper</td><td></td><td style="text-align:left;"></td></tr><tr><td><a href="https://github.com/baidu/uid-generator" target="_blank" rel="noreferrer">uid-generator</a></td><td style="text-align:right;"></td><td style="text-align:right;"></td><td></td><td>关系型数据库</td><td></td><td style="text-align:left;"></td></tr><tr><td><a href="https://github.com/didi/tinyid" target="_blank" rel="noreferrer">TinyID</a></td><td style="text-align:right;">不支持<strong>按位分区算法</strong></td><td style="text-align:right;"></td><td></td><td></td><td></td><td style="text-align:left;"></td></tr></tbody></table><h2 id="号段算法-segmentid" tabindex="-1">号段算法 (<code>SegmentId</code>) <a class="header-anchor" href="#号段算法-segmentid" aria-label="Permalink to &quot;号段算法 (`SegmentId`)&quot;">​</a></h2><table tabindex="0"><thead><tr><th></th><th style="text-align:right;">性能（吞吐量）</th><th style="text-align:right;">稳定性（百分位数）</th><th>自治性（依赖）</th><th>号段分发器</th><th>适应性</th><th>存储空间</th><th>使用方式</th></tr></thead><tbody><tr><td><a href="https://github.com/Ahoo-Wang/CosId" target="_blank" rel="noreferrer">CosId</a></td><td style="text-align:right;">127,439,148(ops/s)</td><td style="text-align:right;">P9999=0.208(us/op)</td><td>依赖<strong>号段分发器</strong></td><td>关系型数据库、Redis、ZooKeeper</td><td>支持<code>Step</code>自动扩缩容</td><td>64-bit</td><td>SDK(推荐)/RPC/RESTful</td></tr><tr><td><a href="https://github.com/Meituan-Dianping/Leaf" target="_blank" rel="noreferrer">Leaf</a></td><td style="text-align:right;"></td><td style="text-align:right;"></td><td></td><td>MySql</td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/baidu/uid-generator" target="_blank" rel="noreferrer">uid-generator</a></td><td style="text-align:right;">不支持<strong>号段算法</strong></td><td style="text-align:right;"></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/didi/tinyid" target="_blank" rel="noreferrer">TinyID</a></td><td style="text-align:right;"></td><td style="text-align:right;"></td><td></td><td>数据库</td><td></td><td></td><td></td></tr></tbody></table>',9)]))}const c=e(i,[["render",l]]);export{u as __pageData,c as default};
